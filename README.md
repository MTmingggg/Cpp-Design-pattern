# Cpp-Design-pattern
C++设计模式。包含4大原则和12种常用的设计模式范例。
# 开闭原则
增加功能是通过增加代码实现，而不是修改！<br>示例：计算器。增加加法、减法功能...
# 迪米特法则（最少知识原则）
不需要把类的细节全暴露给我，暴露个接口类给我就行了。<br>示例：买房。一个个去楼盘看太费事，这时需要个中介（接口），你告诉它需求，它推荐你房源。
# 合成复用原则
继承和组合，优先使用组合。<br>示例：开车。人要开车，不能用人继承具体车，出现同名重载出错。
# 依赖倒转原则
原本是一层一层向底层依赖。如果底层函数变化，那上层全部受影响，不利于维护。
现在业务层和实现层全部依赖于抽象层，实现和业务无关。<br>示例：银行员工。
银行工作人员 用到单一职责原则，三个职责分开，分为专门办理转账业务、存款业务...的工作人员。
业务层依赖于抽象层（更高一层，不是具体办哪个业务的，要想增加一个新业务就很方便（可扩展性强））
# 创建型-01 简单工厂模式（Gof的23种之外）
不想管创建对象，只想把对象拿来用！<br>示例：生产水果1.0。一个个new水果必须关注创建细节，但我不想，于是增加水果工厂接口类。好处：1.客户端和具体实现类解耦。出问题都是工厂的问题。2.对于某些对象创建复杂的情况，现在不用去考虑这些了。
缺点：1.增加新功能是通过修改工厂代码实现，违背开闭原则。2.类的职责过重，如果发生问题，会影响很多使用工厂的模块。
# 创建型-02 工厂方法模式
为了解决简单工厂不符合开闭原则的缺点，将工厂抽象出去。<br>示例：生产水果1.1。让一类水果对应一类生产工厂，所有工厂继承于一个抽象工厂。好处：简单工厂模式 + 符合开闭原则 = 工厂方法模式。缺点：1.类的个数成倍增加，因为增加一个水果类就意味着增加一类生产工厂类，增加维护成本。2.简单工厂模式把判断放在创建哪个对象放在工厂里，需要传参。但工厂方法没有判断逻辑，如果要判断，需要客户自己去判断，而不是工厂。
# 创建型-03 抽象工厂模式
开闭原则下，工厂方法模式仅能生产某个产品等级结构，该模式可生产多个产品等级结构（一维->二维）。<br>示例：生产水果1.2。抽象工厂针对的是产品族（中国生产的香蕉、梨子、苹果，美国生产的香蕉、梨子、苹果），而不是产品等级结构（香蕉、梨子、苹果）。这句话的理解是：在开闭原则下，抽象工厂可以生产多个产品族（增加菲律宾生产的，不修改抽象工厂源代码）。
但是如果产品等级结构中增加西瓜，会修改抽象工厂代码，就不符合开闭原则了。
# 创建型-04 单例模式
全局系统中该类只能有一个对象，不允许用户调用构造函数（禁止自己创建），同时也不能向用户提供用于释放的析构。<br>示例：未使用。懒汉与饿汉的区别：饿汉在main之前执行。因此多线程应用饿汉，或为懒汉加锁。
# 结构型-01 代理模式
不允许直接访问某对象的方法，提供一种方式（代理）来控制对其他对象的访问。<br>示例：登录系统。一个已经写完的系统类，必须要有权限验证（用户名密码），不是所有人都能启动系统。（不允许用户直接从mysys类中调run()，必须通过代理类调），它模拟了一个真正的mysys。代理类需和mysys拥有公共的接口，因此写抽象通用接口类（第二步：需要代理类限制对对象访问的公共接口）。客户端，通过代理登录。
# 结构型-02 外观模式
将复杂的子类系统抽想到同一个的接口进行管理。外界指需要通过这个接口和子类进行交互即可，不必直接和子类交互，避免关心子类细节。<br>示例：智能设备。四个子系统要启动run()，我不用new四次再分别调用run()。外观模式下，创建一个接口（外观类）提供runall()方法给我，我只需new接口，调用runall()即可启动四个子系统。
# 结构型-03 适配器模式
将一个类的接口转换成客户希望的另一个接口，使原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>示例：手机充电。函数对象，这个函数已经写好了，但是它不符合调用的要求（参数数量不一样），要写一个适配器。
# 结构型-04 装饰器模式
对继承的一种替代。给一个类动态增加功能。<br>示例：英雄买装备。装备（装饰物）英雄穿上装饰物应当还是个英雄。
# 行为型-01 模板方法模式
定义一个算法框架，将一些步骤（具备一定特征）的实现延迟到子类。<br>示例：泡茶泡咖啡。实现步骤一样，但每部步现细节不同。可以先定抽象步骤（抽象模板），模板方法make()（算法框架）每次都有这四步。子类继承于它，再把每步实现。
# 行为型-02 策略模式
它对一系列的算法加以封装，为所有算法定义一个抽象的算法接口，并通过继承该抽象算法接口对所有的算法加以封装和实现，具体的算法选择交由客户端决定（策略）。<br>示例：捡装备。每一步具体算法封装好，但它们的执行顺序可以由用户自定义，和模板方法模式正好反过来。
# 行为型-03 命令模式
将客户端各类请求封装成对象进行处理。<br>示例：CS交互。游戏服务器要知道客户端干什么，就要约定一个协议（字符串）。客户端要发送一个东西给服务器，内容是我要升级了。步骤：通过socket建立连接，把字符串发给服务器，服务器一直在监听，服务器解析协议，再进行一些验证，合法后等级加1，再通过socket返回给客户端。
# 行为型-04 观察者模式
一个类的行为将引起很多类发生变化。<br>示例：英雄打boss。观察目标可以不止一个，被通知对象也不止一个，因此都要抽象出来。观察目标可以增加、删除观察者的指针、调用观察者update（boss死了通知每个英雄从进攻状态变为待机状态）
# IDE
Miscrosoft Visual Studio 2015


